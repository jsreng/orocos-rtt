#ifndef ORO_CORBA_SCRIPTINGACCESS_IDL
#define ORO_CORBA_SCRIPTINGACCESS_IDL

#ifdef CORBA_IS_TAO
//resolves LNK2005
#include <tao/orb.idl>
#endif
#include "Operations.idl"

module RTT
{
  module corba
  {

    /**
     * This interface provides easy access to
     * a task's programs and state machines.
     * @ingroup CompIDL
     */
    interface CScriptingAccess
    {
      /**
       * An exception indicating that a
       * Program or StateMachine could not be
       * loaded or unloaded.
       */
      exception CLoadException
      {
	string what;
      };


      typedef sequence<string> CProgramNames;
      typedef sequence<string> CStateMachineNames;

      /**
       * Parse and execute a statement.
       * @retval -1 if a parse error occured.
       * @retval 0 if a statement was executed.
       * @return a positive integer if \a code was a
       * command. This number is the command's ticket
       * number.
       */
      long execute( in string code );

      /**
       * Return the command with a given ticket number.
       */
      CCommand getCommand( in long ticket);

      void loadPrograms( in string code, in string filename ) raises (CLoadException);
      void unloadProgram( in string name ) raises (CLoadException);

      boolean  hasProgram(in string name);
      CProgramNames getPrograms();
      long getProgramLine(in string name);
      string getProgramText(in string name );
      string getProgramStatus(in string name );

      void loadStateMachines( in string code, in string filename ) raises (CLoadException);
      void unloadStateMachine( in string name ) raises (CLoadException);

      boolean  hasStateMachine(in string name);
      CStateMachineNames getStateMachines();
      string getStateMachineText(in string name );
      string getStateMachineStatus(in string name );
      long getStateMachineLine(in string name );
      string getCurrentState(in string name );

    };
  };
};
#endif
